{-# LANGUAGE OverloadedStrings #-}
module EDN.CodeGen.TypeScript
  ( generateTypeScript
  , generateTSParser
  ) where

import Data.Text (Text)
import qualified Data.Text as T
import EDN.Types

generateTypeScript :: Text
generateTypeScript = T.unlines
  [ "// EDN Parser Library - Generated by Haskell EDN Parser"
  , ""
  , "export type EDNValueType = "
  , "  | 'nil'"
  , "  | 'bool'"
  , "  | 'string'"
  , "  | 'char'"
  , "  | 'number'"
  , "  | 'keyword'"
  , "  | 'symbol'"
  , "  | 'list'"
  , "  | 'vector'"
  , "  | 'set'"
  , "  | 'map'"
  , "  | 'tagged';"
  , ""
  , "export interface TaggedValue {"
  , "  tag: string;"
  , "  value: EDNValue;"
  , "}"
  , ""
  , "export class EDNValue {"
  , "  public readonly type: EDNValueType;"
  , "  public readonly value: any;"
  , ""
  , "  constructor(type: EDNValueType, value: any) {"
  , "    this.type = type;"
  , "    this.value = value;"
  , "  }"
  , ""
  , "  isNil(): boolean {"
  , "    return this.type === 'nil';"
  , "  }"
  , ""
  , "  isBool(): boolean {"
  , "    return this.type === 'bool';"
  , "  }"
  , ""
  , "  isString(): boolean {"
  , "    return this.type === 'string';"
  , "  }"
  , ""
  , "  isNumber(): boolean {"
  , "    return this.type === 'number';"
  , "  }"
  , ""
  , "  isKeyword(): boolean {"
  , "    return this.type === 'keyword';"
  , "  }"
  , ""
  , "  isSymbol(): boolean {"
  , "    return this.type === 'symbol';"
  , "  }"
  , ""
  , "  isList(): boolean {"
  , "    return this.type === 'list';"
  , "  }"
  , ""
  , "  isVector(): boolean {"
  , "    return this.type === 'vector';"
  , "  }"
  , ""
  , "  isSet(): boolean {"
  , "    return this.type === 'set';"
  , "  }"
  , ""
  , "  isMap(): boolean {"
  , "    return this.type === 'map';"
  , "  }"
  , ""
  , "  isTagged(): boolean {"
  , "    return this.type === 'tagged';"
  , "  }"
  , ""
  , "  asBool(): boolean {"
  , "    if (!this.isBool()) throw new Error('EDNValue is not a boolean');"
  , "    return this.value as boolean;"
  , "  }"
  , ""
  , "  asString(): string {"
  , "    if (!this.isString()) throw new Error('EDNValue is not a string');"
  , "    return this.value as string;"
  , "  }"
  , ""
  , "  asNumber(): number {"
  , "    if (!this.isNumber()) throw new Error('EDNValue is not a number');"
  , "    return this.value as number;"
  , "  }"
  , ""
  , "  asKeyword(): string {"
  , "    if (!this.isKeyword()) throw new Error('EDNValue is not a keyword');"
  , "    return this.value as string;"
  , "  }"
  , ""
  , "  asSymbol(): string {"
  , "    if (!this.isSymbol()) throw new Error('EDNValue is not a symbol');"
  , "    return this.value as string;"
  , "  }"
  , ""
  , "  asList(): EDNValue[] {"
  , "    if (!this.isList()) throw new Error('EDNValue is not a list');"
  , "    return this.value as EDNValue[];"
  , "  }"
  , ""
  , "  asVector(): EDNValue[] {"
  , "    if (!this.isVector()) throw new Error('EDNValue is not a vector');"
  , "    return this.value as EDNValue[];"
  , "  }"
  , ""
  , "  asSet(): Set<EDNValue> {"
  , "    if (!this.isSet()) throw new Error('EDNValue is not a set');"
  , "    return this.value as Set<EDNValue>;"
  , "  }"
  , ""
  , "  asMap(): Map<EDNValue, EDNValue> {"
  , "    if (!this.isMap()) throw new Error('EDNValue is not a map');"
  , "    return this.value as Map<EDNValue, EDNValue>;"
  , "  }"
  , ""
  , "  asTagged(): TaggedValue {"
  , "    if (!this.isTagged()) throw new Error('EDNValue is not tagged');"
  , "    return this.value as TaggedValue;"
  , "  }"
  , "}"
  , ""
  , "export class EDNParseError extends Error {"
  , "  public readonly position: number;"
  , ""
  , "  constructor(message: string, position: number) {"
  , "    super(message);"
  , "    this.name = 'EDNParseError';"
  , "    this.position = position;"
  , "  }"
  , "}"
  , ""
  , "export class EDNParser {"
  , "  private pos: number = 0;"
  , "  private input: string = '';"
  , ""
  , "  public parse(input: string): EDNValue {"
  , "    this.input = input;"
  , "    this.pos = 0;"
  , "    this.skipWhitespace();"
  , "    return this.parseValue();"
  , "  }"
  , ""
  , "  private skipWhitespace(): void {"
  , "    while (this.pos < this.input.length) {"
  , "      const char = this.input[this.pos];"
  , "      if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {"
  , "        this.pos++;"
  , "      } else if (char === ';') {"
  , "        while (this.pos < this.input.length && this.input[this.pos] !== '\\n') {"
  , "          this.pos++;"
  , "        }"
  , "      } else {"
  , "        break;"
  , "      }"
  , "    }"
  , "  }"
  , ""
  , "  private parseValue(): EDNValue {"
  , "    this.skipWhitespace();"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new EDNParseError('Unexpected end of input', this.pos);"
  , "    }"
  , ""
  , "    const char = this.input[this.pos];"
  , "    "
  , "    if (char === 'n' && this.input.substr(this.pos, 3) === 'nil') {"
  , "      this.pos += 3;"
  , "      return new EDNValue('nil', null);"
  , "    }"
  , "    "
  , "    if (char === 't' && this.input.substr(this.pos, 4) === 'true') {"
  , "      this.pos += 4;"
  , "      return new EDNValue('bool', true);"
  , "    }"
  , "    "
  , "    if (char === 'f' && this.input.substr(this.pos, 5) === 'false') {"
  , "      this.pos += 5;"
  , "      return new EDNValue('bool', false);"
  , "    }"
  , "    "
  , "    if (char === '\"') {"
  , "      return this.parseString();"
  , "    }"
  , "    "
  , "    if (char === '\\\\') {"
  , "      return this.parseChar();"
  , "    }"
  , "    "
  , "    if (char === ':') {"
  , "      return this.parseKeyword();"
  , "    }"
  , "    "
  , "    if (char === '(') {"
  , "      return this.parseList();"
  , "    }"
  , "    "
  , "    if (char === '[') {"
  , "      return this.parseVector();"
  , "    }"
  , "    "
  , "    if (char === '{') {"
  , "      return this.parseMap();"
  , "    }"
  , "    "
  , "    if (char === '#') {"
  , "      return this.parseTaggedOrSet();"
  , "    }"
  , "    "
  , "    if (this.isDigit(char) || char === '-' || char === '+') {"
  , "      return this.parseNumber();"
  , "    }"
  , "    "
  , "    return this.parseSymbol();"
  , "  }"
  , ""
  , "  private parseString(): EDNValue {"
  , "    this.pos++; // skip opening quote"
  , "    let result = '';"
  , "    while (this.pos < this.input.length) {"
  , "      const char = this.input[this.pos];"
  , "      if (char === '\"') {"
  , "        this.pos++;"
  , "        return new EDNValue('string', result);"
  , "      } else if (char === '\\\\') {"
  , "        this.pos++;"
  , "        const escaped = this.input[this.pos++];"
  , "        switch (escaped) {"
  , "          case 'n': result += '\\n'; break;"
  , "          case 't': result += '\\t'; break;"
  , "          case 'r': result += '\\r'; break;"
  , "          case '\\\\': result += '\\\\'; break;"
  , "          case '\"': result += '\"'; break;"
  , "          default: result += escaped;"
  , "        }"
  , "      } else {"
  , "        result += char;"
  , "        this.pos++;"
  , "      }"
  , "    }"
  , "    throw new EDNParseError('Unterminated string', this.pos);"
  , "  }"
  , ""
  , "  private parseChar(): EDNValue {"
  , "    this.pos++; // skip backslash"
  , "    if (this.input.substr(this.pos, 7) === 'newline') {"
  , "      this.pos += 7;"
  , "      return new EDNValue('char', '\\n');"
  , "    } else if (this.input.substr(this.pos, 5) === 'space') {"
  , "      this.pos += 5;"
  , "      return new EDNValue('char', ' ');"
  , "    } else if (this.input.substr(this.pos, 3) === 'tab') {"
  , "      this.pos += 3;"
  , "      return new EDNValue('char', '\\t');"
  , "    } else if (this.input.substr(this.pos, 6) === 'return') {"
  , "      this.pos += 6;"
  , "      return new EDNValue('char', '\\r');"
  , "    } else {"
  , "      const char = this.input[this.pos++];"
  , "      return new EDNValue('char', char);"
  , "    }"
  , "  }"
  , ""
  , "  private parseKeyword(): EDNValue {"
  , "    this.pos++; // skip colon"
  , "    let result = '';"
  , "    while (this.pos < this.input.length && this.isSymbolChar(this.input[this.pos])) {"
  , "      result += this.input[this.pos++];"
  , "    }"
  , "    return new EDNValue('keyword', result);"
  , "  }"
  , ""
  , "  private parseSymbol(): EDNValue {"
  , "    let result = '';"
  , "    while (this.pos < this.input.length && this.isSymbolChar(this.input[this.pos])) {"
  , "      result += this.input[this.pos++];"
  , "    }"
  , "    return new EDNValue('symbol', result);"
  , "  }"
  , ""
  , "  private parseNumber(): EDNValue {"
  , "    let result = '';"
  , "    while (this.pos < this.input.length) {"
  , "      const char = this.input[this.pos];"
  , "      if (this.isDigit(char) || char === '.' || char === '-' || char === '+' || char === 'e' || char === 'E') {"
  , "        result += char;"
  , "        this.pos++;"
  , "      } else {"
  , "        break;"
  , "      }"
  , "    }"
  , "    return new EDNValue('number', parseFloat(result));"
  , "  }"
  , ""
  , "  private parseList(): EDNValue {"
  , "    this.pos++; // skip opening paren"
  , "    const items: EDNValue[] = [];"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== ')') {"
  , "      items.push(this.parseValue());"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new EDNParseError('Unterminated list', this.pos);"
  , "    }"
  , "    this.pos++; // skip closing paren"
  , "    return new EDNValue('list', items);"
  , "  }"
  , ""
  , "  private parseVector(): EDNValue {"
  , "    this.pos++; // skip opening bracket"
  , "    const items: EDNValue[] = [];"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== ']') {"
  , "      items.push(this.parseValue());"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new EDNParseError('Unterminated vector', this.pos);"
  , "    }"
  , "    this.pos++; // skip closing bracket"
  , "    return new EDNValue('vector', items);"
  , "  }"
  , ""
  , "  private parseMap(): EDNValue {"
  , "    this.pos++; // skip opening brace"
  , "    const map = new Map<EDNValue, EDNValue>();"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== '}') {"
  , "      const key = this.parseValue();"
  , "      this.skipWhitespace();"
  , "      const value = this.parseValue();"
  , "      map.set(key, value);"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new EDNParseError('Unterminated map', this.pos);"
  , "    }"
  , "    this.pos++; // skip closing brace"
  , "    return new EDNValue('map', map);"
  , "  }"
  , ""
  , "  private parseTaggedOrSet(): EDNValue {"
  , "    this.pos++; // skip #"
  , "    if (this.input[this.pos] === '{') {"
  , "      return this.parseSet();"
  , "    } else {"
  , "      return this.parseTagged();"
  , "    }"
  , "  }"
  , ""
  , "  private parseSet(): EDNValue {"
  , "    this.pos++; // skip opening brace"
  , "    const items = new Set<EDNValue>();"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== '}') {"
  , "      items.add(this.parseValue());"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new EDNParseError('Unterminated set', this.pos);"
  , "    }"
  , "    this.pos++; // skip closing brace"
  , "    return new EDNValue('set', items);"
  , "  }"
  , ""
  , "  private parseTagged(): EDNValue {"
  , "    let tag = '';"
  , "    while (this.pos < this.input.length && this.isSymbolChar(this.input[this.pos])) {"
  , "      tag += this.input[this.pos++];"
  , "    }"
  , "    this.skipWhitespace();"
  , "    const value = this.parseValue();"
  , "    return new EDNValue('tagged', { tag, value });"
  , "  }"
  , ""
  , "  private isDigit(char: string): boolean {"
  , "    return char >= '0' && char <= '9';"
  , "  }"
  , ""
  , "  private isSymbolChar(char: string): boolean {"
  , "    return /[a-zA-Z0-9.\\-_+*\\/?$%&=<>]/.test(char);"
  , "  }"
  , "}"
  ]

generateTSParser :: Text -> Text
generateTSParser _ = generateTypeScript