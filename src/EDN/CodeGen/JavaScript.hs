{-# LANGUAGE OverloadedStrings #-}
module EDN.CodeGen.JavaScript
  ( generateJavaScript
  , generateJSParser
  ) where

import Data.Text (Text)
import qualified Data.Text as T
import EDN.Types

generateJavaScript :: Text
generateJavaScript = T.unlines
  [ "// EDN Parser Library - Generated by Haskell EDN Parser"
  , ""
  , "class EDNValue {"
  , "  constructor(type, value) {"
  , "    this.type = type;"
  , "    this.value = value;"
  , "  }"
  , "}"
  , ""
  , "class EDNParser {"
  , "  constructor() {"
  , "    this.pos = 0;"
  , "    this.input = '';"
  , "  }"
  , ""
  , "  parse(input) {"
  , "    this.input = input;"
  , "    this.pos = 0;"
  , "    this.skipWhitespace();"
  , "    return this.parseValue();"
  , "  }"
  , ""
  , "  skipWhitespace() {"
  , "    while (this.pos < this.input.length) {"
  , "      const char = this.input[this.pos];"
  , "      if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {"
  , "        this.pos++;"
  , "      } else if (char === ';') {"
  , "        while (this.pos < this.input.length && this.input[this.pos] !== '\\n') {"
  , "          this.pos++;"
  , "        }"
  , "      } else {"
  , "        break;"
  , "      }"
  , "    }"
  , "  }"
  , ""
  , "  parseValue() {"
  , "    this.skipWhitespace();"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new Error('Unexpected end of input');"
  , "    }"
  , ""
  , "    const char = this.input[this.pos];"
  , "    "
  , "    if (char === 'n' && this.input.substr(this.pos, 3) === 'nil') {"
  , "      this.pos += 3;"
  , "      return new EDNValue('nil', null);"
  , "    }"
  , "    "
  , "    if (char === 't' && this.input.substr(this.pos, 4) === 'true') {"
  , "      this.pos += 4;"
  , "      return new EDNValue('bool', true);"
  , "    }"
  , "    "
  , "    if (char === 'f' && this.input.substr(this.pos, 5) === 'false') {"
  , "      this.pos += 5;"
  , "      return new EDNValue('bool', false);"
  , "    }"
  , "    "
  , "    if (char === '\"') {"
  , "      return this.parseString();"
  , "    }"
  , "    "
  , "    if (char === '\\\\') {"
  , "      return this.parseChar();"
  , "    }"
  , "    "
  , "    if (char === ':') {"
  , "      return this.parseKeyword();"
  , "    }"
  , "    "
  , "    if (char === '(') {"
  , "      return this.parseList();"
  , "    }"
  , "    "
  , "    if (char === '[') {"
  , "      return this.parseVector();"
  , "    }"
  , "    "
  , "    if (char === '{') {"
  , "      return this.parseMap();"
  , "    }"
  , "    "
  , "    if (char === '#') {"
  , "      return this.parseTaggedOrSet();"
  , "    }"
  , "    "
  , "    if (this.isDigit(char) || char === '-' || char === '+') {"
  , "      return this.parseNumber();"
  , "    }"
  , "    "
  , "    return this.parseSymbol();"
  , "  }"
  , ""
  , "  parseString() {"
  , "    this.pos++; // skip opening quote"
  , "    let result = '';"
  , "    while (this.pos < this.input.length) {"
  , "      const char = this.input[this.pos];"
  , "      if (char === '\"') {"
  , "        this.pos++;"
  , "        return new EDNValue('string', result);"
  , "      } else if (char === '\\\\') {"
  , "        this.pos++;"
  , "        const escaped = this.input[this.pos++];"
  , "        switch (escaped) {"
  , "          case 'n': result += '\\n'; break;"
  , "          case 't': result += '\\t'; break;"
  , "          case 'r': result += '\\r'; break;"
  , "          case '\\\\': result += '\\\\'; break;"
  , "          case '\"': result += '\"'; break;"
  , "          default: result += escaped;"
  , "        }"
  , "      } else {"
  , "        result += char;"
  , "        this.pos++;"
  , "      }"
  , "    }"
  , "    throw new Error('Unterminated string');"
  , "  }"
  , ""
  , "  parseChar() {"
  , "    this.pos++; // skip backslash"
  , "    if (this.input.substr(this.pos, 7) === 'newline') {"
  , "      this.pos += 7;"
  , "      return new EDNValue('char', '\\n');"
  , "    } else if (this.input.substr(this.pos, 5) === 'space') {"
  , "      this.pos += 5;"
  , "      return new EDNValue('char', ' ');"
  , "    } else if (this.input.substr(this.pos, 3) === 'tab') {"
  , "      this.pos += 3;"
  , "      return new EDNValue('char', '\\t');"
  , "    } else if (this.input.substr(this.pos, 6) === 'return') {"
  , "      this.pos += 6;"
  , "      return new EDNValue('char', '\\r');"
  , "    } else {"
  , "      const char = this.input[this.pos++];"
  , "      return new EDNValue('char', char);"
  , "    }"
  , "  }"
  , ""
  , "  parseKeyword() {"
  , "    this.pos++; // skip colon"
  , "    let result = '';"
  , "    while (this.pos < this.input.length && this.isSymbolChar(this.input[this.pos])) {"
  , "      result += this.input[this.pos++];"
  , "    }"
  , "    return new EDNValue('keyword', result);"
  , "  }"
  , ""
  , "  parseSymbol() {"
  , "    let result = '';"
  , "    while (this.pos < this.input.length && this.isSymbolChar(this.input[this.pos])) {"
  , "      result += this.input[this.pos++];"
  , "    }"
  , "    return new EDNValue('symbol', result);"
  , "  }"
  , ""
  , "  parseNumber() {"
  , "    let result = '';"
  , "    while (this.pos < this.input.length) {"
  , "      const char = this.input[this.pos];"
  , "      if (this.isDigit(char) || char === '.' || char === '-' || char === '+' || char === 'e' || char === 'E') {"
  , "        result += char;"
  , "        this.pos++;"
  , "      } else {"
  , "        break;"
  , "      }"
  , "    }"
  , "    return new EDNValue('number', parseFloat(result));"
  , "  }"
  , ""
  , "  parseList() {"
  , "    this.pos++; // skip opening paren"
  , "    const items = [];"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== ')') {"
  , "      items.push(this.parseValue());"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new Error('Unterminated list');"
  , "    }"
  , "    this.pos++; // skip closing paren"
  , "    return new EDNValue('list', items);"
  , "  }"
  , ""
  , "  parseVector() {"
  , "    this.pos++; // skip opening bracket"
  , "    const items = [];"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== ']') {"
  , "      items.push(this.parseValue());"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new Error('Unterminated vector');"
  , "    }"
  , "    this.pos++; // skip closing bracket"
  , "    return new EDNValue('vector', items);"
  , "  }"
  , ""
  , "  parseMap() {"
  , "    this.pos++; // skip opening brace"
  , "    const map = new Map();"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== '}') {"
  , "      const key = this.parseValue();"
  , "      this.skipWhitespace();"
  , "      const value = this.parseValue();"
  , "      map.set(key, value);"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new Error('Unterminated map');"
  , "    }"
  , "    this.pos++; // skip closing brace"
  , "    return new EDNValue('map', map);"
  , "  }"
  , ""
  , "  parseTaggedOrSet() {"
  , "    this.pos++; // skip #"
  , "    if (this.input[this.pos] === '{') {"
  , "      return this.parseSet();"
  , "    } else {"
  , "      return this.parseTagged();"
  , "    }"
  , "  }"
  , ""
  , "  parseSet() {"
  , "    this.pos++; // skip opening brace"
  , "    const items = new Set();"
  , "    this.skipWhitespace();"
  , "    while (this.pos < this.input.length && this.input[this.pos] !== '}') {"
  , "      items.add(this.parseValue());"
  , "      this.skipWhitespace();"
  , "    }"
  , "    if (this.pos >= this.input.length) {"
  , "      throw new Error('Unterminated set');"
  , "    }"
  , "    this.pos++; // skip closing brace"
  , "    return new EDNValue('set', items);"
  , "  }"
  , ""
  , "  parseTagged() {"
  , "    let tag = '';"
  , "    while (this.pos < this.input.length && this.isSymbolChar(this.input[this.pos])) {"
  , "      tag += this.input[this.pos++];"
  , "    }"
  , "    this.skipWhitespace();"
  , "    const value = this.parseValue();"
  , "    return new EDNValue('tagged', { tag, value });"
  , "  }"
  , ""
  , "  isDigit(char) {"
  , "    return char >= '0' && char <= '9';"
  , "  }"
  , ""
  , "  isSymbolChar(char) {"
  , "    return /[a-zA-Z0-9.\\-_+*\\/?$%&=<>]/.test(char);"
  , "  }"
  , "}"
  , ""
  , "// Export for Node.js or browser"
  , "if (typeof module !== 'undefined' && module.exports) {"
  , "  module.exports = { EDNParser, EDNValue };"
  , "} else if (typeof window !== 'undefined') {"
  , "  window.EDNParser = EDNParser;"
  , "  window.EDNValue = EDNValue;"
  , "}"
  ]

generateJSParser :: Text -> Text
generateJSParser _ = generateJavaScript